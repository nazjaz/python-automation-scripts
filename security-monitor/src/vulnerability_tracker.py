"""Track security vulnerabilities."""

from datetime import datetime, timedelta
from typing import Dict, List, Optional

from src.database import DatabaseManager


class VulnerabilityTracker:
    """Track security vulnerabilities."""

    def __init__(self, db_manager: DatabaseManager, config: Dict):
        """Initialize vulnerability tracker.

        Args:
            db_manager: Database manager instance.
            config: Configuration dictionary.
        """
        self.db_manager = db_manager
        self.config = config

    def track_vulnerability(self, vulnerability_id: str) -> Dict[str, any]:
        """Track vulnerability status.

        Args:
            vulnerability_id: Vulnerability identifier.

        Returns:
            Dictionary with vulnerability tracking information.
        """
        vulnerability = self.db_manager.get_vulnerability(vulnerability_id)

        if not vulnerability:
            return {"error": "Vulnerability not found"}

        fixes = self.db_manager.get_vulnerability_fixes(vulnerability.id)
        timeline = self.db_manager.get_remediation_timeline(vulnerability.id)

        days_open = None
        if vulnerability.discovered_at:
            days_open = (datetime.utcnow() - vulnerability.discovered_at).days

        return {
            "vulnerability_id": vulnerability_id,
            "title": vulnerability.title,
            "severity": vulnerability.severity,
            "cvss_score": vulnerability.cvss_score,
            "status": vulnerability.status,
            "cve_id": vulnerability.cve_id,
            "component": vulnerability.component,
            "discovered_at": vulnerability.discovered_at,
            "fixed_at": vulnerability.fixed_at,
            "days_open": days_open,
            "total_fixes": len(fixes),
            "has_timeline": timeline is not None,
            "target_fix_date": timeline.target_fix_date if timeline else None,
        }

    def get_vulnerability_statistics(
        self, application_id: Optional[int] = None
    ) -> Dict[str, any]:
        """Get vulnerability statistics.

        Args:
            application_id: Optional application ID to filter by.

        Returns:
            Dictionary with vulnerability statistics.
        """
        session = self.db_manager.get_session()
        try:
            from src.database import Vulnerability
            from collections import Counter

            query = session.query(Vulnerability)

            if application_id:
                query = query.filter(Vulnerability.application_id == application_id)

            vulnerabilities = query.all()

            total_vulnerabilities = len(vulnerabilities)
            open_vulnerabilities = len([v for v in vulnerabilities if v.status == "open"])
            fixed_vulnerabilities = len([v for v in vulnerabilities if v.status == "fixed"])

            severity_counts = Counter(v.status for v in vulnerabilities if v.status)
            severity_distribution = Counter(v.severity for v in vulnerabilities if v.severity)

            return {
                "total_vulnerabilities": total_vulnerabilities,
                "open_vulnerabilities": open_vulnerabilities,
                "fixed_vulnerabilities": fixed_vulnerabilities,
                "by_status": dict(severity_counts),
                "by_severity": dict(severity_distribution),
            }
        finally:
            session.close()

    def get_critical_vulnerabilities(
        self, application_id: Optional[int] = None, limit: int = 20
    ) -> List[Dict[str, any]]:
        """Get critical vulnerabilities.

        Args:
            application_id: Optional application ID to filter by.
            limit: Maximum number of vulnerabilities to return.

        Returns:
            List of critical vulnerability dictionaries.
        """
        session = self.db_manager.get_session()
        try:
            from src.database import Vulnerability

            query = (
                session.query(Vulnerability)
                .filter(
                    Vulnerability.severity == "critical",
                    Vulnerability.status == "open",
                )
                .order_by(Vulnerability.cvss_score.desc().nullslast())
            )

            if application_id:
                query = query.filter(Vulnerability.application_id == application_id)

            vulnerabilities = query.limit(limit).all()

            return [
                {
                    "vulnerability_id": v.vulnerability_id,
                    "title": v.title,
                    "cvss_score": v.cvss_score,
                    "cve_id": v.cve_id,
                    "component": v.component,
                    "discovered_at": v.discovered_at,
                }
                for v in vulnerabilities
            ]
        finally:
            session.close()

    def get_overdue_vulnerabilities(
        self, application_id: Optional[int] = None
    ) -> List[Dict[str, any]]:
        """Get overdue vulnerabilities (past target fix date).

        Args:
            application_id: Optional application ID to filter by.

        Returns:
            List of overdue vulnerability dictionaries.
        """
        session = self.db_manager.get_session()
        try:
            from src.database import Vulnerability, RemediationTimeline

            query = (
                session.query(Vulnerability)
                .join(RemediationTimeline)
                .filter(
                    Vulnerability.status == "open",
                    RemediationTimeline.target_fix_date < datetime.utcnow(),
                )
            )

            if application_id:
                query = query.filter(Vulnerability.application_id == application_id)

            vulnerabilities = query.all()

            overdue = []
            for v in vulnerabilities:
                timeline = self.db_manager.get_remediation_timeline(v.id)
                if timeline:
                    days_overdue = (datetime.utcnow() - timeline.target_fix_date).days
                    overdue.append({
                        "vulnerability_id": v.vulnerability_id,
                        "title": v.title,
                        "severity": v.severity,
                        "target_fix_date": timeline.target_fix_date,
                        "days_overdue": days_overdue,
                    })

            return sorted(overdue, key=lambda x: x["days_overdue"], reverse=True)
        finally:
            session.close()
